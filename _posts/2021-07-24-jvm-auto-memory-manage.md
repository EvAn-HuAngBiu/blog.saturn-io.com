---
layout: post
title: JVM--自动内存管理
categories: JVM
keywords: JVM
---

# JVM--自动内存管理

> 本文是《深入理解Java虚拟机》周志明 第3版 的笔记整理

## Java内存区域

### 运行时数据区域

Java内存整体布局结构如下：

![Java运行时数据区域](
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/Java运行时数据区域.png)

#### 程序计数器

程序计数器是**线程私有**的，是**唯一一个没有定义OutOfMemoryError和GC**的内存区域，它可以看做是当前线程所执行的字节码的行号指示器，所以**它只对于执行Java代码才有意义**，而执行Native代码则是无意义的，其值是空的。

#### 虚拟机栈

虚拟机栈是**线程私有**的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行时的线程内存模型：每个方法被执行的时候，Java虚拟机同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。也就是说方**法是以栈帧的形式在虚拟机栈中出入**，**要给某个方法的栈帧分配多少内存空间可以通过Class文件得知**（后续会分析），这种内存空间分配并不是具体的大小，而是指抽象空间的大小，如局部变量槽的个数。

**局部变量表作为栈帧中的一部分也是私有的，它存放了编译器可知的数据类型(boolean、char、int等)、对象引用类型（不代表对象本身，而是指向对象实例地址的指针或代表对象的句柄等内容）和returnAddress类型（指向了一条字节码指令的地址）**

上述数据类型在局部变量表中是以**局部变量槽**(Slot)的形式进行存储的，**槽的宽度为32位**（4B），对于**long、double型变量会使用两个槽进行存储**。

本区域中如果线程请求深度大于虚拟机运行的深度则会抛出**StackOverflowError**异常；如果Java虚拟机栈空间可以动态扩展（HotSpot不行），当内存不足时则会抛出**OutOfMemoryError**异常

#### 本地方法栈

本地方法栈和虚拟机栈的作用类似，区别就是虚拟机栈是为Java方法也就是字节码服务的，而本地方法栈则为Native方法服务。其异常一样，当线程请求深度大于虚拟机运行的深度则会抛出**StackOverflowError**异常；如果Java虚拟机栈空间可以动态扩展（HotSpot不行），当内存不足时则会抛出**OutOfMemoryError**异常。

#### 堆

堆是**线程共享**的内存区域，其唯一作用是存储对象实例（但是反过来说不一定对，**所有对象实例不一定都存储在堆中**，也可以存储在栈上）。**堆是由GC管理的内存区域**。虽然堆是线程共享的，但是为了提升对象分配的效率，通常会为每个线程分配一定的私有堆内存空间，称之为TLAB（Thread Local Allocation Buffer）。

由于堆内存空间是可以动态扩展（通过-Xms -Xmx虚拟机参数）的，所以堆区存在**OutOfMemoryError**异常。

#### 方法区

方法区是**线程共享**的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、几十遍一起编译后的代码缓存等数据。

这里注意方法区的一个说法，**方法区只是一个逻辑概念和具体的实现无关，JDK8以前方法区由永久代实现，JDK8后方法区由元空间实现**。

同时还要注意，**方法区中只包括类的定义信息，但是类的实例、静态变量、常量都存储在堆中**。这里的常量包括String的intern放置的运行时常量，也包括String常量，所以常量池大多数都存储在堆区，而不是方法区（元空间）。

总而言之就是，和实际类型、变量相关的常量池都被移入堆中了，而方法区只保留了编译器生成的各种字面量与符号引用。

#### 运行时常量池

运行时常量池是方法区的一部分，它保存了Class文件中的常量池表，包括编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。所以我们说，虽然我们认知中的常量被移入堆中了，但是表示类信息的常量还留在方法区中，重新组成了运行时常量池。当然除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

**综上所述，运行时常量池存储的是和类元信息相关的常量，其余常量已经被移入堆中了。**

> 提前解释一下直接引用和符号引用：
>
> 直接引用：直接引用可以是
>
> （1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
>
> （2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
>
> （3）一个能间接定位到目标的句柄
>
> 直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。
>
> 比如我们定义：String s = "abc"; System.out.println(s); 这个s就是符号引用
>
> 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。
>
> 而如果我们直接System.out.println("abc"); 那我们使用的就是直接引用

### 

## HotSpot虚拟机对象

### 对象的创建

#### 创建流程

对象的创建流程可以总结成以下步骤：

1. 当虚拟机遇到一条new指令时，首先检查这个指令能否在常量池中找到一个类的符号引用，如果找不到则出错退出；
2. 否则检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有则需要先执行类的初始化流程；
3. 在类加载检查通过后，则虚拟机需要为类分配内存，类对象需要的内存大小在类加载完成后就已经可以确定了。

#### 内存空间分配

通常来说，虚拟机内存分配一般有两种方式：指针碰撞和空闲列表。

**指针碰撞**：把所有使用过的内存放在一边，通过边界指针来区别已经分配的空间和可用空间。

**空闲列表**：把所有空闲的空间链接成一个链表，每次都从链表中找一块足够大的空间划分给对象实例。

可以看出来，指针碰撞的实现简单但是需要JVM的垃圾清理具有压缩功能，这样内存才能规整；而空闲列表实现复杂，每次可能需要遍历链表才能找到合适的空间，但是其对JVM内存压缩的要求不高。所以对于Serial、ParNew等带压缩整理过程的收集器时，搭配指针碰撞方法既简单又高效；而如果使用像CMS这种基于清除算法的收集器，那么理论上只能使用复杂的空闲列表来分配内存。（这不一定，因为CMS也可以在空闲列表的大空余内存空间上使用指针碰撞的方法实现分配）

#### 内存分配的原子性

虚拟机使用了两种方式来保证内存分配的原子性：**CAS**和**TLAB**。

CAS很好理解，虚拟机使用CAS来更新对象的内存，存在多线程竞争时，只要一个线程成功分配了对象内存，那么其它线程自动失败退出。

TLAB是通过让每个线程在堆中预先分配一块小内存（即本地线程分配缓冲TLAB）来保证线程安全的，只有TLAB满时才会向堆中重新申请，只有在重新申请时才会对缓冲区进行锁定。可以使用虚拟机指令 -XX:+/-UseTLAB来启用或禁用TLAB。

#### 对象的设置

对象在内存分配后，会把除对象头外的所有内容设置为0。如果使用了TLAB，可以提前到分配TLAB时进行初始化。初始化的目的是为了让对象中的属性在没有赋值的时候有一个可用的初始值。

除此之外，还会对对象进行一些必要的设置，包括设置对象是哪个类的实例、如何才能找到类的元信息、对象的哈希码（延迟到调用Object::hashCode时才计算）、对象的GC分代年龄、是否启用偏向锁等，都会记录在**对象头**中

最后在虚拟机层面上的对象已经生成了，此时会执行类的构造函数\<init\>，一般来说new指令之后就会执行\<init\>函数，但这并不一定，因为对象的生成和构造函数呃执行与否没有必然的关联，如果使用`Unsafe`类是可以跳过构造函数环节直接生成对象的，如下代码所示：

```java
class InnerClass {
    private int i = 5;

    public InnerClass() {}

    public int getI() {
        return i;
    }
}

public class CreateInstanceByReflection {
    public static void main(String[] args) throws Exception {
        final Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
        final Field theUnsafeField = unsafeClass.getDeclaredField("theUnsafe");
        theUnsafeField.setAccessible(true);
        final Object unsafe = theUnsafeField.get(null);
        final Method allocateInstance = unsafeClass.getMethod("allocateInstance", Class.class);
        InnerClass user = (InnerClass) allocateInstance.invoke(unsafe, InnerClass.class);
        System.out.println(user.getI());
    }
}
```

这里构造的`InnerClass`实例就不会执行构造函数，最终输出的i为0。

### 对象的内存布局

在Hotspot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。

#### 对象头

包含两类信息，第一类**Mark Work**: 是存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；第二类是类型指针，即对象指向它的类型元数据的指针，虚拟机通过这个指针来确定该对象是哪个类的实例。如果对象是一个数组，那么对象头中还会记录数组的长度。

对象头的结构如下所示，它是会随着锁状态的不同而发生变化的：

![MarkWor](
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/MarkWor.png)

可以看到，在不同的时候Mark Work是不同，这里先解释一下锁状态的概念：

无锁：是对象刚创建出来的初始状态，如果没有对其进行任何加锁操作，那么默认就是无锁状态

偏向锁：这是一个伪加锁状态，当某个线程尝试对一个对象加锁时，那么如果它是无锁状态的，就会首先转化为偏向锁，偏向锁只是把当前线程ID写入对象头，如果线程下一次再次尝试加锁时，只要比较对象头中线程ID是否和当前线程ID一致即可，如果一致，说明其它线程没有对该对象抢锁，所以直接就可以获取锁；而如果当前线程ID和对象头中的线程ID不一样，那么说明存在竞争，会升级为轻量级锁

轻量级锁：利用CAS和自旋尝试抢锁，当自旋到一定次数还无法获得锁时，会升级为重量级锁

重量级锁：是和操作系统相关联的锁，需要向操作系统申请互斥量，是开销最大的一种锁

可以使用jol来获取对象头信息，我们下面给出一个实例信息：

![JOL-Example-Snapshot](
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/JOL-Example-Snapshot.png)

可以看到，对象头一共有12B，实例数据有5B（int为4B，boolean为1B），有效数据为17B，由于对象大小必须是8B的倍数，所以需要填充7B的内容。

对象头的12B中只有前8B表示Mark Work，而后4B表示的是Class pointer即类指针（这里开启了指针压缩，可以用-XX:+/-UseCompressedOop关闭）。阅读Mark Word需要从右向左，但是每一组从左向右读。可以看到最后一组即 00000101（第一行第一列），这里偏向锁位为1，锁标志位为01，表示已经开启偏向锁，而分代年龄则是000，1位unused为0，构成了这8位的内容。

#### 实例数据

实例数据包括父类继承的和子类定义的字段，一般情况下，相同宽度的字段会放在一起存放（8B: longs/doubles、4B: ints、2B: shorts/chars、1B: bytes/booleans、oops），在满足上述条件的基础上，父类中定义的变量会在子类之前。

### 对象访问定位

对象定位指的是如何从一个引用找到堆上的具体对象，Java中的定位方式主要有两种：使用句柄和直接定位。

**句柄访问：**Java堆中划分出一块内存作为句柄池，引用中存储的就是到句柄池中某个句柄的地址，而句柄则分别保存到对象实例数据和对象类型数据的指针。其中对象实例数据存储在堆中，对象类型数据存储在方法区中（元空间）

**直接访问：**引用直接指向堆中的对象地址，而对象自身负责存储到类型的指针。

可以看出，句柄访问是一种间接访问，它需要两次访问内存才能得到对象，但是其优点是稳定，在对象被移动时（如GC时）只会改变句柄中的实例数据指针，而引用本身不会发生改变；而直接访问的优点就是快，节省了一次指针定位时间的开销。**Hotspot采用的是直接访问的方式**。

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/Oops-Visit-By-Direct.png" alt="Oops-Visit-By-Direct" style="zoom:50%;" />

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/Oops-Visit-By-Handle.png" alt="Oops-Visit-By-Handle" style="zoom:50%;" />

### JVM常见异常实验



## 垃圾收集器

### 垃圾存活判断

常见的垃圾回收算法有：

1. 引用计数：缺点无法避免循环引用问题

2. 可达性分析算法：如果某个对象到GC Root没有任何引用链相连，说明这个对象是一个游离的对象，可以被GC回收

   常见的引用链有：**虚拟机栈（栈帧中的本地变量表）中引用的对象**、**方法区类静态属性引用的对象**、**方法区中常量引用的对象**、**本地方法栈中JNI（或Native方法）引用的对象**、**Java虚拟机内部的引用（如基本数据类型对应的Class对象、异常对象、系统类加载器等）**、**所有被同步锁持有的对象**

   

### 引用

常见的引用类型有四种：强引用、软引用、弱引用和虚引用

**强引用**：常见的赋值操作就是强引用，如Object a = new Object()，只要强引用关系存在对象就不会被GC回收

**软引用**：被SoftReference持有的对象，软引用关系只有在系统发生内存溢出异常前才会被回收。也即如果第一次GC后的内存空间仍然不能满足分配需要，那么才会进行第二次GC，回收软引用对象。如果软引用对象被回收后还是没有足够的空间，那么才会抛出内存空间不足的异常

**弱引用**：被WeakReference持有的对象，其只能存活到下一次GC发生之前，也就是下一次GC发生的时候，无论内存是否充裕，都会回收弱引用持有的对象。

**虚引用**：虚引用并不是真正的引用，而只是建立起了和被引用对象的一种关联，目的是为了在被引用对象被GC时执行一些额外操作，例如IO中回收分配Native的内存等。虚引用必须和一个引用队列结合起来使用，当被引用对象执行完finalize方法后就会被加入到这个引用队列中，供调用者执行一些额外操作。



### 垃圾收集算法

我们后续讨论的算法都是建立在堆垃圾回收上设计的，但是这并不意味着其它内存区域不需要垃圾回收。例如方法区，方**法区进行内存回收的目的是回收废弃的常量和清理不再使用的类型**，但是相比于堆上的内存回收，方法区的内存回收判定条件苛刻且性价比低：对于常量回收还算简单，但是对于不再使用的类型而言，需要回收就至少要满足不存在当前类的实例、当前类的类加载器已经被回收、当前类的Class对象已经被回收。

#### 分代收集理论

目前大多数垃圾收集器都遵循“分代收集”的理论，它包含三个分代假说：

1. **弱分代假说**：绝大多数对象都是朝升夕灭的
2. **强分代假说**：熬过越多次垃圾手机过程的对象就越难以消亡
3. **跨代引用假说**：跨代引用相比同代引用来说只占少数

综上所述，**一般将Java堆划分为新生代和老年代两个部分**。新生代收集时，每次都会有大量的对象死去，而每次回收后都仅存活少量的对象，将会逐步晋升到老年代中存放。而对于跨代引用问题的解决，一般会在新生代上建立一个全局的数据结构称为记忆集，这个结构把老年代划分为若干小块，标识出老年代的哪一块内存会存在跨代引用。

因为存在分代收集的缘故，所以也会有不同的GC方式：

- 部分收集：目标不是完整收集整个Java堆
  - 新生代收集（Minor GC / Young GC）：只进行新生代的垃圾收集
  - 老年代收集（Major GC / Old GC）：只进行老年代的垃圾收集，只有CMS有这个行为
  - 混合收集（Mixed GC）：收集整个新生代和部分老年代，只有G1有这个行为
- 整堆收集（Full GC）

#### 标记-清除算法

分为两个阶段，先“标记”再“清除”，先标记所有需要收集的对象，在标记完成后统一回收所有要被清除的对象。

**缺点**：1. 执行效率不稳定：如果大量的对象需要被回收，那么就需要进行大量的标记和清除操作，也即标记和清除的效率都随着对象数量的增长而降低；2. 容易产生大量的内存碎片。

#### 标记-复制算法

它将内存分类两个等大的部分，每次只使用其中的一部分，当一半的内存用完的时候就将这一半内存中存活的对象复制到另一半内存中，然后再把已使用过的内存空间一次性的清除掉。

**缺点**：1. 需要额外的空间，对半分内存的空间浪费太大；2. 如果内存中大多数对象都是存活的话，复制需要大量的开销，但是反之开销则很小。

所以为了克服这个缺点，**一般将标记-复制算法用来回收新生代，一般将新生代划分为较大的Eden区和较小的Survivor区**，Hotspot中通过指定-XX:SurvivorRatio参数可以修改两者的比例，默认是8，也就是Eden区占8/(8+1+1)，Survivor From区和To区各占1/(8+1+1)，公式即SurvivorRatio=R，Eden=R/(R+1+1)，From=To=1/(R+1+1)。

这里可以看出Survivor区是明显小于Eden区的，也就是认为每次GC结束后存活的对象必定是很小的，假设R=8，那这里就假定有90%的对象可以被回收，只需要剩下10%的空间即可，但是这种假设一旦失败就需要有内存担保机制来提供可用内存。一般采取的策略是，**如果Survivor区没有足够的空间存放上一次GC后新生代的存活对象，那么就直接进入老年代**。

#### 标记-整理算法

先扫描整个堆，标记出需要清理的对象，然后让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

**缺点**：如果每次都移动一个大对象那么其效率很低，而且这种操作必须暂停用户应用程序才能进行。

一种可行的解决方法：在大多数时候都是用标记-清除算法，暂时容忍内存碎片的存在，知道内存空间的碎片化程度已经大到了影响对象分配时，才使用标记-整理算法收集一次来规整内存空间。



### HotSpot算法实现细节

#### 根节点枚举

根节点前面已经分析过了包含常量与静态变量、栈帧中的本地变量表、Native方法的变量、JVM内部使用的Class变量和异常以及被同步锁持有的对象等。

但是对根节点的标记需要保证**一致性**，也就是这个标记过程必须包装所有根节点不再发生改变，即需要停止用户应用程序来实现（STW）。**根节点枚举阶段是所有垃圾收集器都会发生停顿的阶段**。

> 为了避免GC时需要扫描整个GC Root来寻找可达的对象，HotSpot使用了OopMap结构来保存在某个时间点上栈上本地变量到堆上对象的引用关系，垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。
>
> 我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。



#### 安全点

安全点的设计就是能使得方法在运行到中途时也具备开始GC的能力，上面说到，HotSpot使用OopMap来记录栈上变量引用的堆变量，但是可能导致OopMap变化的指令有非常多，我们无法对每一条指令都生成一个OopMap，这样会带来巨大的内存开销，**所以HotSpot引入了安全点机制，只在特定位置记录了这些信息，同时也规定了应用程序并非在代码指令流的任意位置都能停下来开始垃圾收集，而是强制要求必须执行到达安全点后才能暂停**。

安全点的选定基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的。

同样在发生垃圾收集时，如何让所有线程都跑到最近的安全点停下来，也有两种做法：**抢先式中断**和**主动式中断**

**抢先式中断**：在发生垃圾收集时，系统会把所有线程中断，如果发现有用户线程中断的地方不在安全点上，那么就恢复这条线程运行，让它一会再重新中断，直到跑到安全点上。

**主动式中断**：当需要中断线程时，不直接对线程操作，而是简单的设置一个标志位，各个线程主动轮训这个标志位，如果一旦发现这个标志位为真，那么就在离自己最近的安全点主动中断挂起。一般来说轮询标志的地方和安全点是重合的。



#### 安全区域

但是安全点的设计是有缺陷的，如果某个线程处于Sleep或Block状态，它无法走到最近的安全点时，那么如何解决GC呢？

这里引入了一个安全区域的设计，安全区域就是指在某一段代码片段中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。

当用户线程执行到安全区域时会声明自己处于安全区域内，在线程处于安全区域内的这段时间，虚拟机要发起垃圾收集就不必去管这些已经声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举，如果完成了，那就当做无事发生继续执行；否则就需要等待收到可以离开安全区域的信号后才能离开安全区域。



#### 记忆集和卡表

记忆集和OopMap类似，记录的是从非收集区域指向收集区域的指针集合。而卡表则是为了避免记忆集记录内存精度过小而设计的一种结构，它记录一块内存区域内是否含有跨代指针。

卡表的实现可以简单到使用一个字节数组来实现：`CARD_TABLE[this address >> 9] = 0;`，这个语句表示，卡表的精度为512B，也就是能标记出512B的内存空间中是否包含跨代引用。所以对于每个内存地址，只要将它除以512B就能得到卡表的下标了，只要根据这个下标到CARD_TABLE中判断是否存在跨代引用即可（一个CARD_TABLE对应的块中可能包含不止一个对象，只有有一个存在，就认为需要整体扫描，这是在时间和空间上的一种妥协）。



#### 写屏障

我们已经提出了使用卡表来避免对内存区域的大范围扫描，但是我们还要考虑卡表是如何维护的即卡表是如何变脏的。很显然有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏了，变脏的时间点原则上应该发生在引用类型字段赋值的那一刻。

所以HotSpot引入了写屏障来解决这个问题，写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，除了G1收集器外，其它收集器使用的都是写后屏障，即在赋值后插入更新卡表的操作。



#### 并发的可达性分析

由于上面说过，对于GC Root的寻找已经采用根节点枚举、OopMap等方法进行优化，其查询时间已经相对短暂且固定了，但是从GC Root开始向下遍历所需的停顿时间就和堆的大小成正比了。所以这里理所当然的想到使用并发的方式向下深入标记，让标记线程和用户线程并发，这样可以减少STW的时间。但是这也会带来问题：如果在并发标记完一个死亡对象后，用户线程又重新使用了这个对象，或者把原本应该消亡的对象变为存活了，那么就会带来一系列的问题。

理论证明，当且仅当以下两个条件同时满足时会产生对象消失问题，我们把已经标记存活的对象记为黑色对象，把未标记存活对象记为白色对象，把已经被垃圾收集器访问但当前对象还存在至少一个引用还没有被扫过，那么需要满足：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

为了解决这个问题，一般采用两种方法：增量更新和原始快照法

**增量更新**：破坏第一个条件，当黑色对象插入新的对白色对象的引用时，就把这个新插入的引用记录下来，等并发扫描结束后，再以这些记录过的引用关系中的黑色对象为根，重新扫描一次。（CMS使用）

**原始快照**：破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发结束后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。相当于使用删除前的对象图重新进行一次扫描。（G1、Shenandoah使用）



### 经典垃圾收集器

我们先来看七种不同的垃圾收集器作用的分代情况：

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/GC-Gen-Arch.png" alt="GC-Gen-Arch" style="zoom:30%;" />

#### Serial / Serial Old

流程图：

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/Serial-SerialOld-Process.png" alt="Serial-SerialOld-Process" style="zoom:50%;" />

可以看出来它是单线程的垃圾收集器（单线程是指在进行垃圾收集时，必须暂停所有用户线程直到收集结束）

它虽然要暂停用户线程才能完成收集，但是它简单并且不会发生线程交互，所以回收效率很高，自身的内存开销也很少，在低内存的应用中，它的停顿时间也并非完全不可接受。

#### ParNew

ParNew是Serial收集器的多线程并行版本，其相比Serial的唯一改进就是在新生代垃圾收集时采用了多个线程进行收集：

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/ParNew-SerialOld-Process.png" alt="ParNew-SerialOld-Process" style="zoom:50%;" />

可以看出来ParNew + Serial Old和Serial + Serial Old的差别仅仅在于GC线程的数量上。ParNew默认使用的GC线程数与处理器核心数量相同。

> 解释一下并发和并行：
>
> 并发是指用户线程和垃圾收集器线程之间的关系，说明同一时间垃圾收集线程和用户线程都在运行
>
> 并行是指多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态的

它目前唯一的用途就是和CMS收集器配合使用，CMS清理老年代，ParNew清理新生代（因为别的收集器除Serial外不支持和CMS搭配使用）。

#### Parallel Scavenge / Parallel Old

Parallel Scavenge是一款新生代收集器，同样基于标记-复制算法实现，也是能够并行收集的多线程收集器；而Parallel Old则是一款老年代收集器，基于标记-整理算法实现，同样支持并行收集。二者组合的流程图如下：

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/ParallelScavenge-ParallelOld-Process.png" alt="ParallelScavenge-ParallelOld-Process" style="zoom:50%;" />

可以看到，它和ParNew在新生代上完全没有区别，仅仅在老年代上采用了多线程收集。但是Praallel收集器的关注点并不是缩短停顿时间，而是达到一个可控制的吞吐量。吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值：
$$
\mbox{吞吐量} = \frac{\mbox{运行用户代码时间}}{\mbox{运行用户代码时间} + \mbox{运行垃圾收集时间}}
$$
追求短停顿时间可以提升与用户交互的流畅程度以及可以保证服务响应质量，提升用户体验；而高吞吐率则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。Parallel Scavenge提供了以下两个参数来控制吞吐量：

-XX:MaxGCPauseMillis：提供一个大于0的毫秒数，收集器尽力包装内存回收花费的时间不超过用户的设定值，但是垃圾回收时间的减少是以牺牲吞吐量和新生代内存空间为代价换取的，停顿时间虽然下降了，但是整体的吞吐量也必然会下降。原来300M的空间降低为100M，原来运行10秒收集一次，每次收集100毫秒，现在运行5秒收集一次，每次收集70毫秒。显然降低停顿时间的代价就是吞吐量的下降

-XX:GCTimeRatio：提供一个1到99的整数用来表示垃圾收集时间占总时间的比率（吞吐量的倒数），如果设置为19，那么最大垃圾时间比率为1/(1+19)=5%，即允许最大5%的垃圾收集时间。

#### CMS

ConcurrentMarkSweep收集器的目标是获取最短的停顿时间，基于标记-清除算法实现的老年代垃圾收集器，它包含一下四个阶段：

1. 初始标记：标记从GC Root可以**直接**关联到的对象，速度很快，需要STW
2. 并发标记：从GC Root能直接关联到的对象开始遍历整个对象图，时间较长，可以和用户线程并发执行
3. 重新标记：修正并发标记阶段因为用户线程的运作导致可能发生变动的那一部分对象的标记记录，速度较快，需要STW
4. 并发清除：清除被标记死亡的对象，由于不需要移动对象，所以也可以与用户线程并发

我们先来看整个执行的流程图：

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/CMS-Proces.png" alt="CMS-Proces" style="zoom:50%;" />

可以看到只有初始标记和重新标记阶段需要STW，这两个阶段的速度要远比并发标记快，所以整体的STW时间不会太长。CMS在重新标记阶段采用的是增量更新法，就是会记录用户线程对对象图中新加入的存活对象到被标记的死亡对象之间的引用，并从存活对象为根重新扫描。

**缺点**：

1. 对处理器资源敏感，会占用一部分线程，降低总吞吐量。CMS默认启动（处理器核心数+3）/ 4个线程，如果总核心数在4个以上，那么占用率不超过25%并且随着处理器核心数量的增加占用率也越少；反之，如果处理器核心数小于4个，那么就可能会造成很大的影响
2. 无法清除浮动垃圾，浮动垃圾是指在标记过程结束后产生的垃圾，这些垃圾在本次GC中无法被集中清理，只能等待下一次GC来清理。同时CMS运行阶段用户线程也需要并发运行，所以需要预留一部分内存空间给用户线程使用，**对于CMS回收而言，它不会等到老年代被完全填满后才进行回收，可以用虚拟机参数    -XX:CMSInitiatingOccupancyFraction来设置比例**，默认的比例是92，即老年代占用超过92%时才会开始CMS回收。如果还是出现内存不足的情况，就会产生并发失败错误（Concurrent Mode Failure），这时候虚拟机就会冻结用户线程执行，临时启用Serial Old来进行老年代的回收。
3. CMS采用标记-清除算法没有解决内存碎片问题，CMS提供了-XX:UseCMSCompactAtFullCollection参数来控制在不得不进行Full GC时进行内存碎片的整理，同时提供了-XX:CMSFullGCsBeforeCompaction参数来控制执行多少次不进行整理的Full GC后下一次进入Full GC前会先进行整理（默认为0表示每次进入Full GC时都会进行整理）。

#### G1

G1的目标是实现“停顿时间模型”的收集器，停顿时间模型是指能够支持在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。

G1和其它收集器最大的不同点就是跳出了Minor GC、Full GC这个模式，而是**面向堆内存的任何部分来组成回收集，衡量的标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大**，这就是G1收集器的Mixed GC模式。

G1把连续的Java堆划分为多个大小相等的独立区域Region，**每一个Region可以根据需要扮演新生代Eden空间、Survivor空间以及老年代空间**，收集器对扮演不同角色的Region采用不同的策略进行收集。**而对于超过一个Region容量一半的对象会被G1认为是大对象，大对象存储在Humongous Region中，而对于超过了整个Region容量的超级大对象，将会被放在N个连续的Humongous Region中，G1的大多数行为都会将Humongous Region视作老年代的一部分来进行看待**。可以用  -XX:G1HeapRegionSize来设定，值必须是2的次幂。

G1的垃圾回收是以Region为单位的，G1收集器会跟踪各个Region里面的垃圾堆积的价值大小，价值即包括回收获得的空间大小以及回收所需时间的估计值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX:MaxGCPauseMillis，默认是200毫秒），优先处理回收价值收益最大的那些Region。

G1收集器Region分区示意图：

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/G1-Region-Process.png" alt="G1-Region-Process" style="zoom:30%;" />

我们可以将G1的垃圾回收过程分为以下四个步骤：

1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿

   **TAMS**：为了保证在用户线程并发时能在当前Region中继续分配内存产生对象，定义了两个TAMS指针并从Region区域划出一部分空间用于记录并发回收过程中的产生的新对象，这些新对象都必须在TAMS指针位置以上的内存空间进行分配，而在回收时默认在这个地址以上的对象都是被隐式标记过的，即默认它们是存活的，不纳入回收范围。

2. 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，并发时有引用变动的对象会产生漏标问题，G1中会使用原始快照（SATB）算法来解决

3. 最终标记：对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的最后那少量的SATB记录(漏标对象)

4. 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。

<img src="
https://evanblog.oss-cn-shanghai.aliyuncs.com/image/JVM/G1-Process.png" alt="G1-Process" style="zoom:50%;" />

从上述阶段的描述可以知道，G1收集器除了并发标记阶段外，其余阶段也是完全暂停用户线程的，即它并非纯粹追求低延迟，而是在延迟可控的基础上获得尽可能高的吞吐量。

**优点**：与CMS相比，整体采用标记-整理算法，局部采用标记-复制算法，不会产生内存碎片

**缺点**：

1. 内存占用大，如果要维持前述的卡表结构来记录跨Region引用，那么对每个Region都要记录一个这样的数据结构，会比其它收集器浪费更多的空间。
2. 执行负载大，G1不仅要使用写后屏障来维护和更新卡表，为了实现原始快照搜索算法，还要使用写前屏障来跟踪并发时的指针变化情况。

#### Shenandoah

#### ZGC

#### 一些GC相关的虚拟机参数

1. 输出GC日志 **-Xlog:gc -Xlog:gc***
2. Minor GC触发的时机是Eden区没有足够的空间供对象分配使用
3. 大对象直接进入老年代，可以通过虚拟机参数 **-XX:PretenureSizeThreshold** 控制进入老年代对象的大小
4. 长期存活的对象将进入老年代，可以通过虚拟机参数 **-XX:MaxTenuringThreshold** 控制对象熬过多少次GC时进入老年代
5. Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半时，那么年龄大于等于该年龄的对象可以直接进入老年代

